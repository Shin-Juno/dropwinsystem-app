<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>1대1 웹소켓 채팅</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/sockjs-client@1/dist/sockjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@stomp/stompjs@7.0.0/bundles/stomp.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        /* 보라색 대신 검은색 및 회색 톤으로 변경 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
        }
        .chat-container {
            background-color: #ffffff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            height: 80vh; /* 채팅창 높이 고정 */
        }
        .chat-header {
            background-color: #333333; /* 보라색 -> 검은색 */
            color: white;
            padding: 1rem;
            text-align: center;
            font-size: 1.25rem;
            font-weight: 600;
            border-top-left-radius: 12px;
            border-top-right-radius: 12px;
        }
        .messages {
            flex-grow: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            background-color: #e2e8f0;
        }
        .message-wrapper {
            display: flex;
            align-items: flex-end;
            gap: 0.5rem;
        }
        .message-wrapper.sent {
            align-self: flex-end;
            flex-direction: row;
        }
        .message-wrapper.received {
            align-self: flex-start;
            flex-direction: row;
        }
        .message-bubble {
            background-color: #ffffff;
            padding: 0.75rem 1rem;
            border-radius: 18px;
            max-width: 80%;
            word-wrap: break-word;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.08);
            display: flex;
            flex-direction: column;
        }
        .message-bubble.sent {
            background-color: #4a4a4a; /* 보라색 -> 짙은 회색 */
            color: white;
        }
        .message-bubble.received {
            background-color: #ffffff;
            color: #333;
        }
        .chat-input-area {
            display: flex;
            padding: 1rem;
            border-top: 1px solid #e2e8f0;
            background-color: #ffffff;
            gap: 0.5rem;
        }
        .chat-input {
            flex-grow: 1;
            padding: 0.75rem 1rem;
            border: 1px solid #cbd5e0;
            border-radius: 20px;
            font-size: 1rem;
            outline: none;
        }
        .chat-input:focus {
            border-color: #555555; /* 보라색 -> 짙은 회색 */
            box-shadow: 0 0 0 2px rgba(0, 0, 0, 0.1); /* 보라색 그림자 -> 검은색 그림자 */
        }
        .send-button {
            background-color: #333333; /* 보라색 -> 검은색 */
            color: white;
            padding: 0.75rem 1.25rem;
            border-radius: 20px;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: background-color 0.2s ease;
        }
        .send-button:hover {
            background-color: #555555; /* 보라색 -> 짙은 회색 */
        }
        .status-message {
            text-align: center;
            color: #6b7280;
            font-size: 0.875rem;
            margin-top: 0.5rem;
            align-self: center;
        }
        .username-display {
            font-size: 0.75rem;
            color: #6b7280;
            margin-bottom: 0.25rem;
        }
        .message-bubble.sent .username-display {
            text-align: right;
            color: #bbbbbb; /* 보낸 메시지 사용자 이름 색상 변경 */
        }
        .message-bubble.received .username-display {
            text-align: left;
            color: #6b7280;
        }
        .timestamp {
            font-size: 0.7rem;
            color: #9ca3af;
            white-space: nowrap;
            margin-bottom: 0.25rem;
        }
    </style>
</head>
<body>
    <div class="chat-container">
        <div class="chat-header">
            1대1 채팅 - <span id="currentChatPartner">상대방 선택 필요</span>
        </div>
        <div class="messages" id="messages">
            <!-- ★★★ Thymeleaf를 사용하여 DB에서 불러온 과거 메시지 표시 ★★★ -->
            <!-- 이 부분은 서버에서 모델(chatHistory)을 통해 이미 렌더링되므로, JavaScript에서 다시 로드할 필요 없음 -->
            <div th:each="msg : ${chatHistory}"
                 th:classappend="${msg.senderId == loggedInUserId} ? 'sent' : 'received'"
                 class="message-wrapper">
                <div th:classappend="${msg.senderId == loggedInUserId} ? 'sent' : 'received'"
                     class="message-bubble">
                    <div th:unless="${msg.senderId == loggedInUserId}" class="username-display" th:text="${msg.senderId}"></div>
                    <div th:text="${msg.messageContent}"></div>
                </div>
                <div class="timestamp" th:text="${#temporals.format(msg.timestamp, 'HH:mm:ss')}"></div>
            </div>
        </div>
        <div class="chat-input-area">
            <input type="text" id="messageInput" class="chat-input" placeholder="메시지를 입력하세요...">
            <button id="sendButton" class="send-button">전송</button>
        </div>
    </div>

    <script th:inline="javascript"> // Thymeleaf 인라인 JavaScript 사용을 위해 추가

        const messageInput = document.getElementById('messageInput');
        const sendButton = document.getElementById('sendButton');
        const messagesDiv = document.getElementById('messages');
        const currentChatPartnerDisplay = document.getElementById('currentChatPartner');

        let ws; // Stomp Client 객체를 저장할 변수
        let myUserId = 'unknown'; // 로그인한 사용자의 고유 ID (members.id)
        let currentReceiverId = null; // 현재 채팅 중인 상대방의 ID
        let currentChatRoomId = null; // 현재 채팅 중인 채팅방의 ID

        // Thymeleaf 모델에서 넘어온 로그인 유저 ID를 JavaScript 변수에 할당
        const loggedInUserIdFromModel = /*[[${loggedInUserId}]]*/ 'unknown';
        // Thymeleaf 모델에서 넘어온 채팅 기록 (초기 로딩 시 Thymeleaf가 직접 렌더링하므로, JS에서는 직접 사용하지 않음)
        // const initialChatHistory = /*[[${chatHistory}]]*/ [];


        // URL 쿼리 파라미터에서 상대방 ID를 가져오는 함수
        function getUrlParameter(name) {
            name = name.replace(/[\[]/, '\\[').replace(/[\]]/, '\\]');
            var regex = new RegExp('[\\?&]' + name + '=([^&#]*)');
            var results = regex.exec(location.search);
            return results === null ? '' : decodeURIComponent(results[1].replace(/\+/g, ' '));
        };

        // 채팅방 ID 생성 함수 (백엔드와 동일 로직)
        function generateChatRoomId(id1, id2) {
            const ids = [id1, id2].sort(); // 알파벳 순으로 정렬
            return ids[0] + '_' + ids[1];
        }

        // 새 메시지를 화면에 추가하는 함수
        function appendMessage(senderId, messageContent, type, timestamp) {
            const wrapper = document.createElement('div');
            const bubble = document.createElement('div');
            wrapper.classList.add('message-wrapper');
            bubble.classList.add('message-bubble');

            if (type === 'sent') {
                wrapper.classList.add('sent');
                bubble.classList.add('sent');
            } else if (type === 'received') {
                wrapper.classList.add('received');
                bubble.classList.add('received');
            } else if (type === 'status') {
                wrapper.classList.add('status-message');
            }

            if (senderId && type !== 'status') {
                const nameElem = document.createElement('div');
                nameElem.classList.add('username-display');
                nameElem.textContent = senderId; // 사용자 ID를 표시
                bubble.appendChild(nameElem);
            }

            const msgElem = document.createElement('div');
            msgElem.textContent = messageContent;
            bubble.appendChild(msgElem);

            if (type !== 'status' && timestamp) {
                const timeElem = document.createElement('div');
                timeElem.classList.add('timestamp');
                // 서버에서 내려주는 timestamp 포맷에 따라 수정 (ISO 8601 문자열이라면 Date 객체로 변환)
                const date = new Date(timestamp);
                timeElem.textContent = date.toLocaleTimeString('ko-KR', { hour: '2-digit', minute: '2-digit' });

                if (type === 'sent') {
                    // 보낸 메시지는 시간표시가 왼쪽에 오도록 (DOM 순서: 시간 -> 버블)
                    wrapper.append(timeElem, bubble);
                } else {
                    // 받은 메시지는 시간표시가 오른쪽에 오도록 (DOM 순서: 버블 -> 시간)
                    wrapper.append(bubble, timeElem);
                }
            } else {
                wrapper.appendChild(bubble);
            }

            messagesDiv.appendChild(wrapper);
            messagesDiv.scrollTop = messagesDiv.scrollHeight;
        }

        // 기존 메시지 로드 함수 (더 이상 API 호출 안 함, Thymeleaf 모델에서 가져옴)
        // 초기 메시지는 Thymeleaf가 직접 렌더링하므로, 이 함수는 더 이상 호출되지 않음.
        // function loadPreviousMessagesFromModel() {
        //     console.log('초기 메시지 로드 완료 (모델에서 가져옴):', initialChatHistory);
        //     initialChatHistory.forEach(msg => {
        //         const messageType = (msg.senderId === myUserId) ? 'sent' : 'received';
        //         appendMessage(msg.senderId, msg.messageContent, messageType, msg.timestamp);
        //     });
        //     messagesDiv.scrollTop = messagesDiv.scrollHeight; // 로드 후 스크롤 하단으로
        // }

        // 웹소켓 연결 함수 (Stomp.js v7.0.0 버전용)
        function connectWebSocket() {
            // WebSocket 엔드포인트를 /ws로 수정합니다.
            const socket = new SockJS('/ws');  

            ws = new StompJs.Client({ // StompJs.Client 사용
                webSocketFactory: () => socket,
                debug: function(str) {
                    console.log("STOMP Debug: " + str);
                },
                reconnectDelay: 5000,
                heartbeatIncoming: 4000,
                heartbeatOutgoing: 4000
            });

            ws.onConnect = function(frame) {
                console.log('웹소켓 연결 성공 (STOMP): ' + frame);
                appendMessage(null, `연결됨 (${myUserId})`, 'status', null);

                // 채팅방 토픽 구독
                ws.subscribe(`/topic/chat.room.${currentChatRoomId}`, function(messageOutput) {
                    const data = JSON.parse(messageOutput.body);
                    console.log('STOMP 수신 메시지:', data);

                    if (data.chatRoomId === currentChatRoomId) {
                        const sender = data.senderId?.trim() || '익명';
                        const messageType = (sender === myUserId.trim()) ? 'sent' : 'received';
                        const timestamp = data.timestamp;
                        appendMessage(sender, data.messageContent, messageType, timestamp);

                        // 메시지를 수신하면 (내가 보낸 메시지가 아닐 경우) 읽음 처리 API 호출
                        if (messageType === 'received') {
                            markMessagesAsRead(currentChatRoomId, myUserId);
                        }
                    } else {
                        console.log('현재 채팅방이 아닌 다른 채팅방 메시지 수신:', data);
                    }
                });

                // 채팅방 진입 시 모든 메시지를 읽음 처리
                markMessagesAsRead(currentChatRoomId, myUserId);
                // 초기 메시지 로드 후 스크롤을 맨 아래로 이동 (Thymeleaf 렌더링 후)
                messagesDiv.scrollTop = messagesDiv.scrollHeight;
            };

            ws.onStompError = function(frame) {
                console.error('STOMP 에러:', frame.headers['message'], frame.body);
                appendMessage(null, 'STOMP 연결 오류. 재연결 시도 중...', 'status', null);
            };

            ws.onDisconnect = function() {
                console.log('STOMP 연결 끊김');
                appendMessage(null, '연결 끊김. 재연결 시도 중...', 'status', null);
            };

            ws.activate();
        }

        // 메시지 전송 함수
        function sendMessage() {
            const messageText = messageInput.value.trim();
            if (!messageText || !currentReceiverId || !currentChatRoomId) {
                alert('메시지를 입력하거나 채팅할 상대방을 선택하세요.');
                return;
            }

            if (ws && ws.connected) {
                const chatMessage = {
                    chatRoomId: currentChatRoomId,
                    senderId: myUserId,
                    receiverId: currentReceiverId,
                    messageContent: messageText,
                    // timestamp와 isRead는 서버에서 설정
                };

                // STOMP 메시지 전송 (서버의 `/app/chat.send` 엔드포인트로 전송)
                ws.publish({
                    destination: `/app/chat.send`,
                    body: JSON.stringify(chatMessage)
                });
                messageInput.value = '';
            } else {
                appendMessage(null, '메시지를 보낼 수 없습니다. 연결 상태를 확인하세요.', 'status', null);
            }
        }

        // 메시지를 읽음으로 표시하는 API 호출 함수
        function markMessagesAsRead(chatRoomId, userId) {
            fetch(`/api/chat/markAsRead`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    chatRoomId: chatRoomId,
                    userId: userId
                })
            })
            .then(response => {
                if (!response.ok) throw new Error('읽음 처리 실패');
                return response.text();
            })
            .then(data => console.log('메시지 읽음 처리 완료:', data))
            .catch(error => console.error('메시지 읽음 처리 오류:', error));
        }

        sendButton.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                sendMessage();
            }
        });

        // 페이지 로드 시 초기화
        window.onload = () => {
            // 1. 현재 로그인한 사용자 ID를 가져옵니다.
            if (loggedInUserIdFromModel && loggedInUserIdFromModel !== 'unknown') {
                myUserId = loggedInUserIdFromModel;
                console.log('내 사용자 ID (모델에서 가져옴):', myUserId);
                proceedWithChatSetup();
            } else {
                // 모델에서 ID를 받지 못했을 경우 API 호출
                fetch('/api/user/me')
                    .then(res => {
                        if (!res.ok) throw new Error('응답 실패');
                        return res.json();
                    })
                    .then(data => {
                        if (data.loggedIn && data.userId) {
                            myUserId = data.userId;
                            console.log('내 사용자 ID (API에서 가져옴):', myUserId);
                            proceedWithChatSetup();
                        } else {
                            alert('로그인 정보가 없거나 사용자 ID를 가져올 수 없습니다. 로그인 후 다시 시도해주세요.');
                        }
                    })
                    .catch(err => {
                        console.error('로그인 정보 확인 오류:', err);
                        alert('로그인 정보를 가져오는 중 오류가 발생했습니다.');
                    });
            }
        };

        // 채팅 설정 및 웹소켓 연결을 시작하는 함수
        function proceedWithChatSetup() {
            currentReceiverId = getUrlParameter('partnerId');

            if (currentReceiverId && myUserId !== 'unknown') {
                currentChatRoomId = generateChatRoomId(myUserId, currentReceiverId);
                currentChatPartnerDisplay.textContent = currentReceiverId;
                console.log(`현재 채팅 상대: ${currentReceiverId}, 채팅방 ID: ${currentChatRoomId}`);

                // loadPreviousMessagesFromModel(); // ★★★ 이 호출을 제거하여 중복 로딩 방지 ★★★
                connectWebSocket(); // 웹소켓 연결 시작
            } else {
                if (myUserId === 'unknown') {
                     alert('로그인 정보가 유효하지 않아 채팅을 시작할 수 없습니다.');
                } else {
                    alert('채팅할 상대방 ID가 필요합니다. URL에 ?partnerId=상대방ID 를 추가하여 접속해주세요.');
                }
            }
        }
    </script>
</body>
</html>
